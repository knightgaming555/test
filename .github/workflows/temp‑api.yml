name: temp-api-chat
on: workflow_dispatch

jobs:
  realtime_chat_app:
    runs-on: ubuntu-latest
    env:
      NGROK_TOKEN: ${{ secrets.NGROK_TOKEN }}
      # Set LOG_LEVEL to DEBUG for extremely verbose server logs if needed for deep diagnosis
      LOG_LEVEL: INFO # Options: DEBUG, INFO, WARNING, ERROR
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq curl
          python -m pip install --upgrade pip
          # We let pip show its output in case of issues.
          pip install flask flask-socketio eventlet "Werkzeug<3.0.0"

      - name: Create Real-Time Chat Application
        run: |
          mkdir -p static

          # --- Backend: api.py ---
          cat <<'PY' > api.py
          import os
          import logging
          import threading
          import time
          from datetime import datetime
          from collections import deque

          from flask import Flask, request, jsonify, send_from_directory
          from flask_socketio import SocketIO, emit

          # --- Configuration ---
          LOG_LEVEL_ENV = os.environ.get('LOG_LEVEL', 'INFO').upper()
          MAX_CHAT_HISTORY = 150
          API_LOG_FILE = 'api.log' # File where nohup redirects stdout/stderr

          # --- Logging Setup ---
          # Get Python's numerical log level
          numeric_log_level = getattr(logging, LOG_LEVEL_ENV, logging.INFO)
          if not isinstance(numeric_log_level, int):
              print(f"Warning: Invalid LOG_LEVEL '{LOG_LEVEL_ENV}'. Defaulting to INFO.")
              numeric_log_level = logging.INFO

          logging.basicConfig(
              level=numeric_log_level,
              format='%(asctime)s [%(levelname)s] %(name)s: %(message)s (%(threadName)s)',
              handlers=[logging.StreamHandler()] # Outputs to stdout/stderr (captured by nohup)
          )
          # Get a logger for this specific module
          logger = logging.getLogger(__name__)

          # --- Flask & SocketIO App Setup ---
          app = Flask(__name__, static_folder='static', static_url_path='')
          app.config['SECRET_KEY'] = os.urandom(32)

          # Ensure Flask's own logger aligns with the desired level
          app.logger.setLevel(numeric_log_level)

          socketio = SocketIO(
              app,
              async_mode='eventlet',
              cors_allowed_origins='*', # Allow all for ngrok
              # Enable SocketIO's internal loggers if our log level is DEBUG
              logger=(numeric_log_level == logging.DEBUG),
              engineio_logger=(numeric_log_level == logging.DEBUG)
          )
          logger.info(f"Flask and SocketIO initialized. Log level: {LOG_LEVEL_ENV}")

          # --- In-memory Data Stores ---
          chat_history = deque(maxlen=MAX_CHAT_HISTORY)
          connected_users = {} # sid -> {'name': display_name, 'sid': sid}

          # --- Helper Functions ---
          def get_current_timestamp():
              return datetime.now().strftime('%H:%M:%S')

          def create_message_object(user_display_name, text, msg_type="user_message", **kwargs):
              return {
                  'user': user_display_name,
                  'text': text,
                  'timestamp': get_current_timestamp(),
                  'type': msg_type,
                  **kwargs
              }

          # --- HTTP Routes ---
          @app.route('/')
          def index_route():
              # logger.debug("Serving index.html")
              return send_from_directory(app.static_folder, 'index.html')

          @app.route('/ping')
          def ping_route():
              logger.info("HTTP /ping route hit")
              return jsonify(ok=True, message="Pong!", server_time=datetime.utcnow().isoformat())

          # --- SocketIO Event Handlers ---
          @socketio.on('connect')
          def handle_user_connect():
              sid = request.sid
              user_display_name = f"User-{sid[:5]}"
              connected_users[sid] = {'name': user_display_name, 'sid': sid}
              logger.info(f"Client connected: {user_display_name} (SID: {sid})")

              socketio.emit('chat_history', list(chat_history), to=sid)
              logger.debug(f"Sent chat history ({len(chat_history)} items) to {user_display_name}")

              join_message = create_message_object("System", f"{user_display_name} has joined.", msg_type="system_notification")
              chat_history.append(join_message)
              socketio.emit('new_message', join_message, broadcast=True)

          @socketio.on('disconnect')
          def handle_user_disconnect():
              sid = request.sid
              user_info = connected_users.pop(sid, None)
              if user_info:
                  user_display_name = user_info.get('name', f"User-{sid[:5]}")
                  logger.info(f"Client disconnected: {user_display_name} (SID: {sid})")
                  leave_message = create_message_object("System", f"{user_display_name} has left.", msg_type="system_notification")
                  chat_history.append(leave_message)
                  socketio.emit('new_message', leave_message, broadcast=True)
              else:
                  logger.warning(f"Unknown client disconnected (SID: {sid})")

          @socketio.on('send_message')
          def handle_send_chat_message(data):
              sid = request.sid
              user_info = connected_users.get(sid)
              if not user_info:
                  logger.warning(f"Message from unknown SID {sid}. Data: {data}. Ignoring.")
                  socketio.emit('error_message', {'error': 'User not recognized. Please reconnect.'}, to=sid)
                  return

              user_display_name = user_info.get('name', f"Anonymous-{sid[:5]}")
              message_text = data.get('text', '').strip()

              if not message_text:
                  logger.debug(f"Empty message from {user_display_name}, ignoring.")
                  return

              logger.info(f"Message from {user_display_name} (SID: {sid}): '{message_text}'")
              new_msg_obj = create_message_object(user_display_name, message_text, msg_type="user_message", sid=sid)
              chat_history.append(new_msg_obj)
              socketio.emit('new_message', new_msg_obj, broadcast=True)

          # --- Background Thread for Tailing and Broadcasting Server Logs ---
          def broadcast_server_logs():
              try:
                  open(API_LOG_FILE, 'a').close()
              except IOError as e:
                  logger.error(f"Failed to touch {API_LOG_FILE} for log broadcasting: {e}")
              
              pos = 0
              logger.info("Server log broadcasting thread started.")
              while True:
                  try:
                      with open(API_LOG_FILE, 'r') as f:
                          f.seek(pos)
                          for line_content in f:
                              if line_content.strip():
                                  socketio.emit('server_log', {'line': line_content.strip()})
                          pos = f.tell()
                  except FileNotFoundError:
                      time.sleep(2) 
                      pos = 0
                  except Exception as e:
                      logger.error(f"Error in broadcast_server_logs: {e}", exc_info=(numeric_log_level == logging.DEBUG))
                      time.sleep(5)
                      pos = 0 
                  time.sleep(0.5)

          # --- Main Execution Guard ---
          if __name__ == '__main__':
              try:
                  logger.info(f"Attempting to start Real-Time Chat Server on 0.0.0.0:8000. PID: {os.getpid()}")
                  
                  log_broadcaster_thread = threading.Thread(target=broadcast_server_logs, name="LogBroadcaster", daemon=True)
                  log_broadcaster_thread.start()

                  logger.info(f"SocketIO server starting with eventlet...")
                  # The socketio.run() call is blocking.
                  socketio.run(app, host='0.0.0.0', port=8000, use_reloader=False)
                  
                  # This part will only be reached if socketio.run() exits, which it shouldn't normally.
                  logger.info("SocketIO server has stopped.")

              except Exception as e:
                  logger.critical(f"CRITICAL ERROR during server startup: {e}", exc_info=True)
                  # In a real nohup scenario, this critical log should appear in api.log
                  # We exit explicitly to make it clear the process failed if it gets here.
                  raise # Reraise after logging
          PY

          # --- Frontend: static/index.html (Identical to previous correct version) ---
          cat <<'HTML' > static/index.html
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Real-Time Chat & Logs</title>
              <style>
                  :root { --primary-color: #007bff; --light-gray: #f8f9fa; --medium-gray: #e9ecef; --dark-gray: #343a40; --text-color: #212529; --border-color: #dee2e6; }
                  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; background-color: var(--light-gray); color: var(--text-color); display: flex; flex-direction: column; height: 100vh; line-height: 1.6; }
                  header { background-color: var(--primary-color); color: white; padding: 1rem 1.5rem; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 10; }
                  header h1 { margin: 0; font-size: 1.8rem; }
                  .status-bar { padding: 0.5rem 1.5rem; background-color: var(--medium-gray); font-size: 0.9em; text-align: center; border-bottom: 1px solid var(--border-color); }
                  .main-container { display: flex; flex-grow: 1; padding: 1rem; gap: 1rem; overflow: hidden; }
                  .panel { background-color: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); display: flex; flex-direction: column; overflow: hidden; }
                  .chat-panel { flex: 3; }
                  .logs-panel { flex: 1; }
                  .panel-header { padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color); background-color: var(--light-gray); }
                  .panel-header h2 { margin: 0; font-size: 1.1rem; color: var(--dark-gray); }
                  .messages-area, .logs-area { list-style: none; margin: 0; padding: 1rem; overflow-y: auto; flex-grow: 1; word-break: break-word; }
                  .message-item { margin-bottom: 0.75rem; padding: 0.5rem 0.75rem; border-radius: 6px; }
                  .message-item .timestamp { font-size: 0.75em; color: #777; margin-left: 0.5em; float: right; }
                  .message-item .user { font-weight: bold; }
                  .user-message { background-color: #e7f3ff; border-left: 3px solid var(--primary-color); }
                  .user-message .user { color: var(--primary-color); }
                  .system-notification { background-color: #f1f3f5; color: #555; font-style: italic; text-align: center; font-size: 0.9em; padding: 0.5rem; }
                  .my-message { background-color: #d1e7dd; border-left: 3px solid #198754; } /* Optional for self-messages */
                  .log-entry { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size: 0.8em; padding: 0.2rem 0; border-bottom: 1px dashed #f0f0f0; }
                  .log-entry:last-child { border-bottom: none; }
                  .input-form { display: flex; padding: 0.75rem; border-top: 1px solid var(--border-color); background-color: var(--light-gray); }
                  #messageInput { flex-grow: 1; padding: 0.6rem 0.9rem; border: 1px solid var(--border-color); border-radius: 20px; outline: none; margin-right: 0.5rem; font-size: 0.95rem; }
                  #sendButton { padding: 0.6rem 1.2rem; background-color: var(--primary-color); color: white; border: none; border-radius: 20px; cursor: pointer; font-weight: 500; font-size: 0.95rem; transition: background-color 0.2s; }
                  #sendButton:hover { background-color: #0056b3; }
                  #sendButton:disabled { background-color: #aaa; cursor: not-allowed; }
              </style>
          </head>
          <body>
              <header><h1>Chat Room & Server Monitor</h1></header>
              <div id="connectionStatus" class="status-bar">Attempting to connect...</div>

              <div class="main-container">
                  <div class="panel chat-panel">
                      <div class="panel-header"><h2>Chat Messages</h2></div>
                      <ul id="messageList" class="messages-area"></ul>
                      <form id="chatForm" class="input-form">
                          <input type="text" id="messageInput" placeholder="Type a message and press Enter..." autocomplete="off" />
                          <button type="submit" id="sendButton">Send</button>
                      </form>
                  </div>
                  <div class="panel logs-panel">
                      <div class="panel-header"><h2>Live Server Logs</h2></div>
                      <ul id="logList" class="logs-area"></ul>
                  </div>
              </div>

              <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
              <script>
                  document.addEventListener('DOMContentLoaded', () => {
                      const socket = io({ transports: ['websocket', 'polling'] }); // Defaults to current host

                      const chatForm = document.getElementById('chatForm');
                      const messageInput = document.getElementById('messageInput');
                      const sendButton = document.getElementById('sendButton');
                      const messageList = document.getElementById('messageList');
                      const logList = document.getElementById('logList');
                      const connectionStatus = document.getElementById('connectionStatus');
                      
                      let currentSocketID = null;

                      function appendMessageToChat(msgObj) {
                          const item = document.createElement('li');
                          item.classList.add('message-item', msgObj.type); 
                          const userSpan = document.createElement('span');
                          userSpan.classList.add('user');
                          userSpan.textContent = msgObj.user ? msgObj.user + ': ' : '';
                          const textSpan = document.createElement('span');
                          textSpan.classList.add('text');
                          textSpan.textContent = msgObj.text; 
                          const timeSpan = document.createElement('span');
                          timeSpan.classList.add('timestamp');
                          timeSpan.textContent = msgObj.timestamp;
                          if (msgObj.type === 'user_message') {
                              item.appendChild(userSpan);
                              item.appendChild(textSpan);
                              item.appendChild(timeSpan);
                          } else { 
                              item.appendChild(textSpan); 
                          }
                          messageList.appendChild(item);
                          messageList.scrollTop = messageList.scrollHeight; 
                      }

                      function appendLogEntry(logObj) {
                          const item = document.createElement('li');
                          item.classList.add('log-entry');
                          item.textContent = logObj.line; 
                          logList.appendChild(item);
                          logList.scrollTop = logList.scrollHeight;
                      }

                      socket.on('connect', () => {
                          currentSocketID = socket.id;
                          console.log('CLIENT: Successfully connected to server. SID:', currentSocketID);
                          connectionStatus.textContent = 'Status: Connected';
                          connectionStatus.style.backgroundColor = '#d1e7dd';
                          connectionStatus.style.color = '#0f5132';
                          sendButton.disabled = false;
                          messageInput.disabled = false;
                      });

                      socket.on('disconnect', (reason) => {
                          console.warn('CLIENT: Disconnected from server. Reason:', reason);
                          connectionStatus.textContent = `Status: Disconnected (${reason})`;
                          connectionStatus.style.backgroundColor = '#f8d7da';
                          connectionStatus.style.color = '#842029';
                          sendButton.disabled = true;
                          messageInput.disabled = true;
                          if (reason === 'io server disconnect') {
                            // the disconnection was initiated by the server, you need to reconnect manually
                            // socket.connect(); // Be careful with auto-reconnecting to avoid loops if server keeps disconnecting
                          }
                      });

                      socket.on('connect_error', (error) => {
                          console.error('CLIENT: Connection attempt failed:', error);
                          connectionStatus.textContent = `Status: Connection Error (Details in console)`;
                          connectionStatus.style.backgroundColor = '#fff3cd';
                          connectionStatus.style.color = '#664d03';
                          sendButton.disabled = true;
                          messageInput.disabled = true;
                      });

                      socket.on('chat_history', (historyArray) => {
                          console.log('CLIENT: Received chat history:', historyArray.length, 'messages');
                          messageList.innerHTML = ''; 
                          historyArray.forEach(appendMessageToChat);
                      });

                      socket.on('new_message', (msgObj) => {
                          console.log('CLIENT: Received new message:', msgObj);
                          appendMessageToChat(msgObj);
                      });

                      socket.on('server_log', (logObj) => {
                          appendLogEntry(logObj);
                      });

                      socket.on('error_message', (errObj) => {
                          console.error('CLIENT: Server error message:', errObj.error);
                          alert('Server Error: ' + errObj.error);
                      });

                      chatForm.addEventListener('submit', (event) => {
                          event.preventDefault(); 
                          const messageText = messageInput.value.trim();
                          if (messageText && socket.connected) {
                              socket.emit('send_message', { text: messageText });
                              messageInput.value = ''; 
                          }
                          messageInput.focus(); 
                      });

                      sendButton.disabled = true;
                      messageInput.disabled = true;
                  });
              </script>
          </body>
          </html>
          HTML

      - name: Start API and ngrok tunnel
        shell: bash -e {0} # Ensure script exits on error
        run: |
          echo "Starting the Python API application (api.py) in the background..."
          # Start with nohup and redirect stdout/stderr to api.log
          nohup python api.py > api.log 2>&1 &
          PYTHON_PID=$!
          echo "Python process started with PID: $PYTHON_PID. Waiting for it to initialize..."
          
          # Wait a bit longer and check if the Python process is still running.
          sleep 8 

          # Check if Python process is alive; if not, cat api.log and exit
          if ! ps -p $PYTHON_PID > /dev/null; then
            echo "‚ùå CRITICAL: Python server (PID $PYTHON_PID) is NOT RUNNING after startup!"
            echo "--- Contents of api.log ---"
            cat api.log || echo "api.log not found or empty."
            echo "---------------------------"
            exit 1
          else
            echo "‚úÖ Python server (PID $PYTHON_PID) appears to be running."
            echo "--- Checking local Flask /ping endpoint ---"
            # Try to curl the local /ping endpoint
            if curl --fail --silent --max-time 5 http://localhost:8000/ping > /dev/null; then
              echo "‚úÖ Local /ping endpoint is responsive."
            else
              echo "‚ö†Ô∏è Local /ping endpoint NOT responsive. Check api.log."
              # Don't exit here, ngrok might still work if it's just /ping misbehaving but Socket.IO is fine.
            fi
            echo "-----------------------------------------"
          fi
          
          echo "Setting up ngrok..."
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update && sudo apt-get install -y ngrok
          ngrok config add-authtoken "$NGROK_TOKEN"
          
          echo "Starting ngrok tunnel for http://localhost:8000 ..."
          nohup ngrok http 8000 --log=stdout --log-level=debug > ngrok.log 2>&1 &
          NGROK_PID=$!
          echo "Ngrok process started with PID: $NGROK_PID. Waiting for tunnel..."
          sleep 8 # Increased wait time for ngrok tunnel and API

          NGROK_API_URL="http://localhost:4040/api/tunnels"
          PUBLIC_URL=""
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ -z "$PUBLIC_URL" ] && [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
            # Fetch HTTPS tunnel specifically if available, otherwise any tunnel.
            CURL_OUTPUT=$(curl --silent --max-time 5 "$NGROK_API_URL")
            PUBLIC_URL=$(echo "$CURL_OUTPUT" | jq -r '.tunnels[] | select(.proto=="https") | .public_url // empty' | head -n 1)
            if [ -z "$PUBLIC_URL" ]; then # Fallback to any http tunnel if https not found
                 PUBLIC_URL=$(echo "$CURL_OUTPUT" | jq -r '.tunnels[] | select(.proto=="http") | .public_url // empty' | head -n 1)
            fi

            if [ -z "$PUBLIC_URL" ]; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Failed to get ngrok URL (attempt ${RETRY_COUNT}/${MAX_RETRIES}). Raw ngrok API output:"
              echo "$CURL_OUTPUT"
              echo "Retrying in 3 seconds..."
              sleep 3
            fi
          done

          if [ -n "$PUBLIC_URL" ]; then
            echo "üöÄ Ngrok Public URL: $PUBLIC_URL"
            echo "üí° Inspect ngrok status: curl http://localhost:4040/api/status"
          else
            echo "‚ùå CRITICAL: Failed to retrieve ngrok public URL after $MAX_RETRIES attempts."
            echo "--- ngrok.log ---"
            cat ngrok.log || echo "ngrok.log not found."
            echo "--- api.log (ensure Python server didn't crash) ---"
            cat api.log || echo "api.log not found."
            exit 1
          fi
          
          echo "--- Recent entries from api.log (Python App) ---"
          tail -n 50 api.log || echo "api.log not found or empty."
          echo "------------------------------------------------"
          echo "--- Recent entries from ngrok.log ---"
          tail -n 20 ngrok.log || echo "ngrok.log not found or empty."
          echo "-------------------------------------"

      - name: Keep runner alive for interaction
        run: |
          echo "Runner will stay alive for testing. Access the chat at the Ngrok Public URL shown above."
          echo "IMPORTANT: Open your browser's Developer Console (F12) on the ngrok page to see client-side logs and network activity."
          sleep 3600 
