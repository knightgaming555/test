name: realtime-chat-workflow

on:
  workflow_dispatch:

jobs:
  chat_application_server:
    runs-on: ubuntu-latest
    env:
      NGROK_TOKEN: ${{ secrets.NGROK_TOKEN }}
      LOG_LEVEL: INFO # Default, used by Python backend
      PYTHONUNBUFFERED: "1" # Ensures Python logs appear in order for tailing

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install System and Python Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
          
          echo "Installing Ngrok..."
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt-get update
          sudo apt-get install -y ngrok
          echo "Ngrok installed."

          echo "Installing Python packages..."
          python -m pip install --upgrade pip
          pip install flask flask-socketio eventlet "Werkzeug<3.0.0"
          echo "Python packages installed."
          pip list

      - name: Create Application Files
        run: |
          mkdir static
          echo "Creating api.py..."
          cat << 'EOF_API_PY' > api.py
import os
import sys
import logging
import threading
import time
from datetime import datetime
from collections import deque

from flask import Flask, request, jsonify, render_template, send_from_directory
from flask_socketio import SocketIO, emit

# --- Global Variables ---
chat_history = deque(maxlen=150)  # Stores the last 150 messages
connected_users = {}  # Stores {sid: display_name}

# --- Logging Setup ---
# Determine log level from environment variable
log_level_str = os.environ.get('LOG_LEVEL', 'INFO').upper()
numeric_level = getattr(logging, log_level_str, logging.INFO)

# Configure logging to output to stdout, which will be captured by nohup into api.log
logging.basicConfig(
    stream=sys.stdout,
    level=numeric_level,
    format='%(asctime)s %(levelname)s [%(name)s:%(lineno)d] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# --- Flask & Socket.IO Setup ---
app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24) # Random secret key for session management
# Use eventlet as the async mode for Flask-SocketIO
socketio = SocketIO(app, async_mode='eventlet', logger=True, engineio_logger=True)


# --- Background Log Broadcaster ---
def broadcast_logs_thread_function(log_file_path, socketio_instance):
    logger.info(f"Log broadcasting thread started for {log_file_path}.")
    file_handler = None
    
    # Retry opening the log file as it might be created by nohup shortly after this thread starts
    for _ in range(10): # Try for ~20 seconds
        try:
            file_handler = open(log_file_path, 'r')
            logger.info(f"Successfully opened {log_file_path} for log broadcasting.")
            break
        except FileNotFoundError:
            logger.warning(f"{log_file_path} not found. Retrying in 2 seconds...")
            time.sleep(2)
        except Exception as e:
            logger.error(f"Error opening {log_file_path} in log broadcaster: {e}")
            return # Critical error, exit thread
    
    if not file_handler:
        logger.error(f"Failed to open {log_file_path} after multiple retries. Log broadcasting disabled.")
        return

    try:
        # Go to the end of the file
        file_handler.seek(0, 2)
        while True:
            line = file_handler.readline()
            if not line:
                time.sleep(0.1)  # Wait for new lines
                continue
            # Emit the new log line to all connected clients
            socketio_instance.emit('server_log', {'line': line.strip()})
    except Exception as e:
        logger.error(f"Error in log broadcasting thread: {e}", exc_info=True)
    finally:
        if file_handler:
            file_handler.close()
        logger.info("Log broadcasting thread stopped.")

# --- Flask HTTP Endpoints ---
@app.route('/')
def index():
    logger.info(f"Serving index.html to {request.remote_addr}")
    return render_template('index.html')

@app.route('/static/<path:filename>')
def static_files(filename):
    return send_from_directory('static', filename)

@app.route('/ping', methods=['GET'])
def ping():
    logger.debug(f"Received ping request from {request.remote_addr}")
    return jsonify({"ok": True, "message": "Pong!"})

# --- Socket.IO Event Handlers ---
@socketio.on('connect')
def handle_connect():
    sid = request.sid
    display_name = f"User-{sid[:5].upper()}"
    connected_users[sid] = display_name
    
    logger.info(f"Client connected: {sid}, assigned display name: {display_name}")

    # Send chat history to the newly connected client
    try:
        emit('chat_history', list(chat_history)) # Send a copy
        logger.debug(f"Sent chat history to {sid}")
    except Exception as e:
        logger.error(f"Error sending chat_history to {sid}: {e}")

    # Create and broadcast a 'user joined' system message
    join_message = {
        'user_display_name': 'System',
        'message_text': f"{display_name} has joined the chat.",
        'timestamp': datetime.now().strftime("%H:%M:%S"),
        'message_type': 'system_notification',
        'sid': 'system'
    }
    chat_history.append(join_message)
    emit('new_message', join_message, broadcast=True)
    logger.info(f"Broadcasted join message for {display_name}")

@socketio.on('disconnect')
def handle_disconnect():
    sid = request.sid
    display_name = connected_users.pop(sid, f"User-{sid[:5].upper()} (Unknown)") # Get display name, provide fallback
    
    logger.info(f"Client disconnected: {sid}, display name: {display_name}")

    # Create and broadcast a 'user left' system message
    leave_message = {
        'user_display_name': 'System',
        'message_text': f"{display_name} has left the chat.",
        'timestamp': datetime.now().strftime("%H:%M:%S"),
        'message_type': 'system_notification',
        'sid': 'system'
    }
    chat_history.append(leave_message)
    emit('new_message', leave_message, broadcast=True)
    logger.info(f"Broadcasted leave message for {display_name}")

@socketio.on('send_message')
def handle_send_message(data):
    sid = request.sid
    user_display_name = connected_users.get(sid, f"User-{sid[:5].upper()} (Unknown)") # Fallback if user not found (should not happen)
    
    message_text = data.get('text', '').strip()
    
    if not message_text:
        logger.warning(f"Empty message received from {sid} ({user_display_name}). Ignoring.")
        emit('error_message', {'message': 'Cannot send an empty message.'}) # Optional: send error back to client
        return

    logger.info(f"Message from {user_display_name} ({sid}): '{message_text}'")
    
    new_msg_obj = {
        'user_display_name': user_display_name,
        'message_text': message_text, # Frontend should sanitize this for display if it uses innerHTML
        'timestamp': datetime.now().strftime("%H:%M:%S"),
        'message_type': 'user_message',
        'sid': sid # Include SID to allow client-side differentiation (e.g., styling own messages)
    }
    
    chat_history.append(new_msg_obj)
    emit('new_message', new_msg_obj, broadcast=True) # Broadcast to all, including sender
    logger.debug(f"Broadcasted new message from {user_display_name} to all clients.")


# --- Main Execution ---
if __name__ == '__main__':
    logger.info("Starting Realtime Chat Application...")
    
    # Start the log broadcasting thread
    # It will tail 'api.log', where nohup redirects stdout/stderr of this script
    log_broadcaster = threading.Thread(
        target=broadcast_logs_thread_function,
        args=('api.log', socketio),
        daemon=True  # Daemon thread will exit when the main program exits
    )
    log_broadcaster.start()

    logger.info("Attempting to start Flask-SocketIO server on 0.0.0.0:8000 with eventlet...")
    try:
        # use_reloader=False is important for running with nohup and for stability with background threads
        socketio.run(app, host='0.0.0.0', port=8000, use_reloader=False, debug=False)
    except Exception as e:
        logger.critical(f"Failed to start Flask-SocketIO server: {e}", exc_info=True)
        sys.exit(1) # Exit if server fails to start
    
    logger.info("Flask-SocketIO server has shut down.")

EOF_API_PY
          echo "api.py created successfully."

          echo "Creating static/index.html..."
          cat << 'EOF_INDEX_HTML' > static/index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Chat</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; display: flex; flex-direction: column; height: 100vh; }
        header { background-color: #333; color: white; padding: 10px 20px; text-align: center; }
        #connection-status { padding: 5px; text-align: center; background-color: #ffc107; font-weight: bold; }
        #connection-status.connected { background-color: #28a745; color: white; }
        #connection-status.disconnected { background-color: #dc3545; color: white; }
        
        .main-content { display: flex; flex: 1; overflow: hidden; padding: 10px; gap: 10px; }
        .panel { background-color: white; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); display: flex; flex-direction: column; flex: 1; overflow: hidden; }
        .panel h2 { font-size: 1.2em; margin: 0; padding: 10px; background-color: #eee; border-bottom: 1px solid #ddd; }
        .scrollable-area { flex: 1; overflow-y: auto; padding: 10px; }
        
        #chat-panel { /* Specific styles if needed */ }
        #logs-panel { /* Specific styles if needed */ }

        #chat-messages .message { margin-bottom: 8px; padding: 8px; border-radius: 4px; word-wrap: break-word; }
        #chat-messages .message .meta { font-size: 0.8em; color: #777; margin-bottom: 3px; }
        #chat-messages .message .meta .user { font-weight: bold; }
        #chat-messages .message .meta .time { margin-left: 10px; }
        #chat-messages .message.user_message { background-color: #e6f7ff; border-left: 3px solid #1890ff; }
        #chat-messages .message.system_notification { background-color: #f0f0f0; border-left: 3px solid #aaa; font-style: italic; }
        #chat-messages .message.current_user { background-color: #d1f7c4; border-left: 3px solid #4CAF50;}


        #log-lines .log-entry { font-family: monospace; font-size: 0.9em; white-space: pre-wrap; margin-bottom: 4px; border-bottom: 1px dotted #eee; padding-bottom: 2px; }

        #chat-form { display: flex; padding: 10px; border-top: 1px solid #ddd; background-color: #f9f9f9;}
        #chat-form input[type="text"] { flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px; }
        #chat-form button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #chat-form button:disabled { background-color: #ccc; }

        @media (max-width: 768px) {
            .main-content { flex-direction: column; }
            .panel { min-height: 200px; /* Ensure panels have some height on small screens */ }
        }
    </style>
</head>
<body>
    <header><h1>Real-Time Chat Application</h1></header>
    <div id="connection-status">Attempting to connect...</div>

    <div class="main-content">
        <div id="chat-panel" class="panel">
            <h2>Chat</h2>
            <div id="chat-messages" class="scrollable-area"></div>
            <form id="chat-form">
                <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off">
                <button type="submit" id="send-button">Send</button>
            </form>
        </div>
        <div id="logs-panel" class="panel">
            <h2>Server Logs</h2>
            <div id="log-lines" class="scrollable-area"></div>
        </div>
    </div>

    <script>
        const socket = io({ autoConnect: false }); // Connect manually later
        let clientSid = null; // To store client's own SID

        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const chatMessages = document.getElementById('chat-messages');
        const logLines = document.getElementById('log-lines');
        const connectionStatus = document.getElementById('connection-status');
        const chatForm = document.getElementById('chat-form');

        function updateConnectionStatus(status, message) {
            connectionStatus.textContent = message;
            connectionStatus.className = status; // 'connected', 'disconnected', or ''
            messageInput.disabled = status !== 'connected';
            sendButton.disabled = status !== 'connected';
        }

        function scrollToBottom(element) {
            element.scrollTop = element.scrollHeight;
        }

        function addMessageToDOM(msg, ownSid) {
            const item = document.createElement('div');
            item.classList.add('message', msg.message_type);
            if (msg.sid === ownSid && msg.message_type === 'user_message') {
                item.classList.add('current_user');
            }
            
            const meta = document.createElement('div');
            meta.classList.add('meta');
            
            const userSpan = document.createElement('span');
            userSpan.classList.add('user');
            userSpan.textContent = msg.user_display_name;
            meta.appendChild(userSpan);

            const timeSpan = document.createElement('span');
            timeSpan.classList.add('time');
            timeSpan.textContent = msg.timestamp;
            meta.appendChild(timeSpan);
            
            item.appendChild(meta);

            const text = document.createElement('div');
            text.classList.add('text');
            text.textContent = msg.message_text; // Use textContent for XSS prevention
            item.appendChild(text);
            
            chatMessages.appendChild(item);
            scrollToBottom(chatMessages);
        }

        function addLogToDOM(log) {
            const item = document.createElement('div');
            item.classList.add('log-entry');
            item.textContent = log.line; // Assuming log.line is plain text
            logLines.appendChild(item);
            scrollToBottom(logLines);
        }

        // Socket.IO event handlers
        socket.on('connect', () => {
            clientSid = socket.id; // Store our own SID
            updateConnectionStatus('connected', 'Status: Connected');
            console.log('Connected to server. SID:', clientSid);
        });

        socket.on('disconnect', (reason) => {
            updateConnectionStatus('disconnected', `Status: Disconnected (${reason})`);
            console.log('Disconnected from server. Reason:', reason);
            clientSid = null;
        });

        socket.on('connect_error', (error) => {
            updateConnectionStatus('', `Status: Connection Error - ${error.message}`);
            console.error('Connection error:', error);
        });

        socket.on('chat_history', (history) => {
            console.log('Received chat history:', history);
            chatMessages.innerHTML = ''; // Clear previous messages
            history.forEach(msg => addMessageToDOM(msg, clientSid));
        });

        socket.on('new_message', (msg) => {
            console.log('Received new message:', msg);
            addMessageToDOM(msg, clientSid);
        });

        socket.on('server_log', (log) => {
            // console.log('Received server log:', log.line); // Can be spammy
            addLogToDOM(log);
        });
        
        socket.on('error_message', (data) => {
            console.error('Server error message:', data.message);
            alert(`Server Error: ${data.message}`);
        });


        // Form submission
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const messageText = messageInput.value.trim();
            if (messageText && socket.connected) {
                socket.emit('send_message', { text: messageText });
                messageInput.value = '';
            }
        });

        // Attempt to connect
        console.log('Attempting to connect to Socket.IO server...');
        socket.connect();

    </script>
</body>
</html>
EOF_INDEX_HTML
          echo "static/index.html created successfully."

          echo "Verifying created files:"
          ls -lR .
          echo "File creation complete."

      - name: Start API and Ngrok Tunnel
        shell: bash # Ensure bash is used for process substitution and other features
        run: |
          echo "Starting Python application in background..."
          nohup python api.py > api.log 2>&1 &
          APP_PID=$!
          echo $APP_PID > app.pid
          echo "Python application started with PID: $APP_PID (output to api.log)"

          echo "Waiting 8 seconds for application to initialize..."
          sleep 8

          echo "Performing Health Check 1 (Python process)..."
          if ps -p $APP_PID > /dev/null; then
            echo "Health Check 1: Python process $APP_PID is running."
          else
            echo "::error::Health Check 1: Python process $APP_PID is NOT running."
            echo "--- api.log contents ---"
            cat api.log
            exit 1
          fi
          
          echo "Performing Health Check 2 (curl /ping)..."
          if curl -sf --max-time 5 http://localhost:8000/ping > /dev/null; then
            echo "Health Check 2: /ping endpoint is responsive."
          else
            echo "::warning::Health Check 2: /ping endpoint not responsive after 5s. This might be okay if Socket.IO is primary, but check logs."
          fi

          echo "Configuring Ngrok with token..."
          ngrok config add-authtoken $NGROK_TOKEN
          
          echo "Starting Ngrok tunnel for http://localhost:8000..."
          nohup ngrok http 8000 --log=stdout --log-level=debug > ngrok.log 2>&1 &
          NGROK_PID=$!
          echo $NGROK_PID > ngrok.pid
          echo "Ngrok started with PID: $NGROK_PID (output to ngrok.log)"

          echo "Waiting 8 seconds for Ngrok tunnel to establish..."
          sleep 8

          echo "Retrieving Ngrok public URL..."
          NGROK_URL=""
          for i in {1..10}; do # Increased retries to 10
            NGROK_URL_HTTPS=$(curl -s --max-time 3 http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.proto=="https") | .public_url')
            NGROK_URL_HTTP=$(curl -s --max-time 3 http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.proto=="http") | .public_url')
            
            if [ -n "$NGROK_URL_HTTPS" ]; then
                NGROK_URL=$NGROK_URL_HTTPS
                break
            elif [ -n "$NGROK_URL_HTTP" ]; then
                NGROK_URL=$NGROK_URL_HTTP
                # Don't break yet, prefer https if it appears later
            fi

            if [ -n "$NGROK_URL" ]; then # If http was found, check if https is also there in same try
                 if [ -n "$NGROK_URL_HTTPS" ]; then NGROK_URL=$NGROK_URL_HTTPS; fi
                 break
            fi
            
            echo "Failed to get Ngrok URL (attempt $i/10). Retrying in 3 seconds..."
            sleep 3
          done

          if [ -z "$NGROK_URL" ]; then
            echo "::error::Could not retrieve Ngrok public URL after multiple attempts."
            echo "--- ngrok.log (last 50 lines) ---"
            tail -n 50 ngrok.log || echo "ngrok.log not found or empty."
            echo "--- api.log (last 50 lines) ---"
            tail -n 50 api.log || echo "api.log not found or empty."
            echo "--- ngrok process status ---"
            ps -p $(cat ngrok.pid) || echo "Ngrok process not found."
            echo "--- app process status ---"
            ps -p $(cat app.pid) || echo "App process not found."
            exit 1
          fi
          
          echo "🚀 Ngrok Public URL: $NGROK_URL"
          echo "You can access the chat application at this URL."
          echo "Please check your browser's developer console for client-side logs and any UI issues."

          echo "--- api.log (last 50 lines) ---"
          tail -n 50 api.log
          echo "---------------------------------"
          echo "--- ngrok.log (last 20 lines) ---"
          tail -n 20 ngrok.log
          echo "---------------------------------"

          echo "Application is running. Keeping runner alive for 1 hour (3600 seconds) for testing."
          echo "To stop earlier, cancel the GitHub Actions workflow run."
          sleep 3600
          
          echo "Stopping application and Ngrok..."
          kill $(cat app.pid) || echo "App already stopped."
          kill $(cat ngrok.pid) || echo "Ngrok already stopped."
          echo "Cleanup complete."
