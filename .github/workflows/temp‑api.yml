name: realtime-chat-workflow

on:
  workflow_dispatch:

jobs:
  chat_application_server:
    runs-on: ubuntu-latest
    env:
      NGROK_TOKEN: ${{ secrets.NGROK_TOKEN }}
      LOG_LEVEL: INFO

    steps:
    # 1. Checkout
    - name: Checkout code
      uses: actions/checkout@v4

    # 2. Python 3.12
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    # 3. System deps
    - name: Install jq & curl
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl unzip

    # 4. Python deps
    - name: Install Python requirements
      run: |
        python -m pip install --upgrade pip
        pip install flask flask-socketio eventlet

    # 5. Generate backend & frontend
    - name: Create application files
      run: |
        mkdir -p static

        # -------- api.py --------
        cat <<'PY' | sed 's/^  //' > api.py
          import os, time, threading, logging
          from collections import deque
          import eventlet
          eventlet.monkey_patch()

          from flask import Flask, jsonify, send_from_directory, request
          from flask_socketio import SocketIO, emit

          # --- logging ---
          LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
          logging.basicConfig(
              level=LOG_LEVEL,
              format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
              handlers=[
                  logging.FileHandler("api.log"),
                  logging.StreamHandler()
              ]
          )
          log = logging.getLogger("chat_app")

          # --- Flask / Socket.IO ---
          app = Flask(__name__, static_folder='static', static_url_path='')
          socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")

          chat_history = deque(maxlen=150)
          users = {}

          @app.route('/')
          def index():
              return send_from_directory('static', 'index.html')

          @app.route('/ping')
          def ping():
              return jsonify(ok=True, message="Pong!")

          # ---- Socket.IO events ----
          @socketio.on('connect')
          def on_connect():
              sid = request.sid
              name = f"User-{sid[:5]}"
              users[sid] = name
              log.info("%s connected", name)

              emit('chat_history', list(chat_history), to=sid)

              msg = {
                  "display_name": "System",
                  "text": f"{name} has joined",
                  "timestamp": time.strftime("%H:%M:%S"),
                  "type": "system_notification"
              }
              chat_history.append(msg)
              socketio.emit('new_message', msg)

          @socketio.on('disconnect')
          def on_disconnect():
              sid = request.sid
              name = users.pop(sid, f"User-{sid[:5]}")
              log.info("%s disconnected", name)

              msg = {
                  "display_name": "System",
                  "text": f"{name} has left",
                  "timestamp": time.strftime("%H:%M:%S"),
                  "type": "system_notification"
              }
              chat_history.append(msg)
              socketio.emit('new_message', msg)

          @socketio.on('send_message')
          def on_send_message(data):
              sid = request.sid
              name = users.get(sid, f"User-{sid[:5]}")
              text = (data or {}).get('text', '').strip()
              if not text:
                  return
              msg = {
                  "display_name": name,
                  "text": text,
                  "timestamp": time.strftime("%H:%M:%S"),
                  "type": "user_message"
              }
              chat_history.append(msg)
              log.info("Message from %s: %s", name, text)
              socketio.emit('new_message', msg)

          # --- Tail api.log and broadcast lines ---
          def tail_logs():
              try:
                  with open('api.log', 'r') as f:
                      f.seek(0, 2)
                      while True:
                          line = f.readline()
                          if line:
                              socketio.emit('server_log', {"line": line.rstrip()})
                          else:
                              eventlet.sleep(1)
              except Exception as e:
                  log.error("Log tail thread error: %s", e)

          if __name__ == '__main__':
              threading.Thread(target=tail_logs, daemon=True).start()
              try:
                  socketio.run(app, host='0.0.0.0', port=8000, use_reloader=False)
              except Exception as e:
                  log.error("Startup failure: %s", e)
                  raise
        PY

        # -------- static/index.html --------
        cat <<'HTML' | sed 's/^  //' > static/index.html
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="utf-8">
            <title>Real‑Time Chat</title>
            <style>
              body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#f4f4f4}
              header{background:#24292e;color:#fff;padding:10px 15px;font-size:18px}
              #status{padding:6px 15px;background:#ededed;font-size:14px}
              #container{display:flex;height:calc(100vh - 80px)}
              #chat,#logs{flex:1;display:flex;flex-direction:column;border-right:1px solid #ddd}
              #logs{border-right:none;background:#fafafa}
              .panel-header{padding:8px 12px;font-weight:bold;background:#e9e9e9}
              .messages{flex:1;overflow-y:auto;padding:10px}
              .message{margin-bottom:8px}
              .message.system{font-style:italic;color:#555}
              .message.self{background:#d7ebff;padding:4px;border-radius:4px}
              #form{display:flex;padding:10px;background:#e9e9e9}
              #form input{flex:1;padding:8px;font-size:14px;border:1px solid #ccc;border-radius:4px}
              #form button{margin-left:8px;padding:8px 12px;border:none;border-radius:4px;background:#24292e;color:#fff;cursor:pointer}
              #form button:disabled{opacity:.5;cursor:not-allowed}
              @media(max-width:768px){#container{flex-direction:column}#chat,#logs{height:50%}}
            </style>
          </head>
          <body>
            <header>Real‑Time Chat Demo</header>
            <div id="status">Status: <span id="connStatus">Connecting…</span></div>
            <div id="container">
              <div id="chat">
                <div class="panel-header">Chat</div>
                <div id="messages" class="messages"></div>
                <form id="form">
                  <input id="input" type="text" placeholder="Type a message…" autocomplete="off">
                  <button type="submit">Send</button>
                </form>
              </div>
              <div id="logs">
                <div class="panel-header">Server Logs</div>
                <div id="logLines" class="messages"></div>
              </div>
            </div>
            <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
            <script>
              const socket = io();
              const statusTxt = document.getElementById('connStatus');
              const msgBox   = document.getElementById('messages');
              const logBox   = document.getElementById('logLines');
              const form     = document.getElementById('form');
              const input    = document.getElementById('input');
              let myName = '';

              const scrollToEnd = el => { el.scrollTop = el.scrollHeight; };

              const addMsg = m => {
                const div = document.createElement('div');
                div.className = 'message ' + (m.type === 'system_notification' ? 'system' : '');
                if (m.display_name === myName) div.classList.add('self');
                div.textContent = `[${m.timestamp}] ${m.display_name}: ${m.text}`;
                msgBox.appendChild(div);
                scrollToEnd(msgBox);
              };

              const addLog = line => {
                const div = document.createElement('div');
                div.className = 'message';
                div.textContent = line;
                logBox.appendChild(div);
                scrollToEnd(logBox);
              };

              socket.on('connect', () => {
                statusTxt.textContent = 'Connected';
                input.disabled = false;
                form.querySelector('button').disabled = false;
                console.log('socket connected');
              });

              socket.on('disconnect', () => {
                statusTxt.textContent = 'Disconnected';
                input.disabled = true;
                form.querySelector('button').disabled = true;
                console.log('socket disconnected');
              });

              socket.on('chat_history', history => {
                msgBox.innerHTML = '';
                history.forEach(addMsg);
              });

              socket.on('new_message', m => {
                if (!myName && m.type === 'user_message') myName = m.display_name;
                addMsg(m);
              });

              socket.on('server_log', d => addLog(d.line));

              form.addEventListener('submit', e => {
                e.preventDefault();
                const text = input.value.trim();
                if (text) {
                  socket.emit('send_message', { text });
                  input.value = '';
                }
              });
            </script>
          </body>
          </html>
        HTML

    # 6. Start backend
    - name: Launch Python chat server
      run: |
        nohup python api.py > api.log 2>&1 &
        echo $! > python.pid
        sleep 8

        # Health‑check 1: process alive?
        if ! kill -0 "$(cat python.pid)"; then
          echo "Python process exited:"
          cat api.log
          exit 1
        fi

        # Health‑check 2: /ping
        curl -s http://localhost:8000/ping || true

    # 7. Ngrok tunnel
    - name: Start ngrok tunnel
      run: |
        # Install ngrok
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
        sudo apt-get update -y
        sudo apt-get install -y ngrok

        # Auth & run
        ngrok config add-authtoken "$NGROK_TOKEN"
        nohup ngrok http 8000 --log=stdout --log-level=debug > ngrok.log 2>&1 &
        echo $! > ngrok.pid

        # Wait & fetch public URL
        for i in {1..5}; do
          sleep 3
          URL=$(curl -s http://localhost:4040/api/tunnels \
            | jq -r '.tunnels[] | select(.proto=="https") | .public_url' | head -n1)
          if [ -n "$URL" ]; then
            echo "🚀 Ngrok Public URL: $URL"
            break
          fi
        done

        if [ -z "$URL" ]; then
          echo "Could not obtain ngrok URL"
          tail -n 50 ngrok.log || true
          tail -n 50 api.log   || true
          exit 1
        fi

    # 8. Show logs & keep runner alive
    - name: Tail logs and keep runner up
      run: |
        echo "===== api.log (last 50) ====="
        tail -n 50 api.log || true
        echo "===== ngrok.log (last 20) ====="
        tail -n 20 ngrok.log || true
        echo "Runner sleeping for manual testing. Open dev‑console for client logs."
        sleep 3600
